/*
 *  charbridge.h - определения ioctl.
 *
 *  Определения, которые здесь находятся, должны помещаться в заголовочный файл потому,
 *  что они потребуются как модулю ядра (charbridge.c), так и
 *  вызывающему процессу (ioctl.c)
 */

#ifndef CHARBRIDGE_H
#define CHARBRIDGE_H

#include <linux/ioctl.h>

/* 
 * Старший номер устройства. В случае использования ioctl,
 * мы уже лишены возможности воспользоваться динамическим номером,
 * поскольку он должен быть известен заранее.
 */
#define MAJOR_NUM 255

/* 
 * Количество "пар" устройств
 * (миноров получается в два раза больше)
 * Т.к. логика построена на том, чтобы для sideA
 * использовать номера от 0..99, а для sideB 100...199
 * ТО "ПАР" УСТРОЙСТВ НЕ МОЖЕТ БЫТЬ БОЛЬШЕ 100!
 */
#define MAX_DEV 10
#define MAX_PAIR 100

// Миноры от 0..99 		- для sideA0...sideA99
// Миноры от 100..199	- для sideB0...sideB99

/* 
 * Операция передачи сообщения драйверу устройства
 */
#define IOCTL_SET_MSG _IOR(MAJOR_NUM, 0, char *)
/*
 * _IOR означает, что команда передает данные
 * от пользовательского процесса к модулю ядра
 *
 * Первый аргумент, MAJOR_NUM -- старший номер устройства.
 *
 * Второй аргумент -- код команды
 * (можно указать иное значение).
 *
 * Третий аргумент -- тип данных, передаваемых в ядро
 */

/* 
 * Операция получения сообщения от драйвера устройства
 */
#define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)
/* 
 * Эта команда IOCTL используется для вывода данных.
 * Нам по прежнему нужен буфер, размещенный в адресном пространстве
 * вызывающего процесса, куда это сообщение должно быть переписано.
 */

/* 
 * Команда получения n-ного байта сообщения
 */
#define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int)
/* 
 * Здесь команда IOCTL работает как на ввод, так и на вывод.
 * Она принимает от пользователя номер байта (n),
 * и возвращает n-ный байт сообщения (Message[n]).
 */

/* 
 * Имя файла устройства
 */
#define DEVICE_FILE_NAME "cbside"
//#define DEV1_NAME "/dev/cbsideA"
//#define DEV2_NAME "/dev/cbsideB"

#endif
